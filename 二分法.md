## 前言
二分查找真的很简单吗？其实也并不简单。看看 Knuth 大佬（发明 KMP 算法的那位）怎么说的：
```
Although the basic idea of binary search is comparatively straightforward, the details can be surprisingly tricky...
```
这句话可以这样理解：**思路很简单，细节是魔鬼**。
## 二分法的三种模型
三种模型分别是：
- 左闭右闭型：[left, right]
- 左闭右开型：[left, right)
- 左开右闭型：(left, right]

三者去别的核心在于while判断语句中有没有等于号，以及中间值的取法。当left 与 right不断接近时，最终left 与right一定会紧挨
#### 中间值取法为 (left + right) / 2 时
![8ffbc79551944ab0888ceba92fd85664](https://user-images.githubusercontent.com/79822208/204229887-6a13dbcd-e7fe-4792-bbb2-7980ddf7726e.png)
当left、mid、right 三数合一时：
- 若判断条件为 left <= right，循环继续，则点②也会被判断，所以为左闭右闭
- 若判断条件为 left < right，循环结束， 则点②点不会被判断，只有点①被检索，所以称为左闭右开（上图分析了 left < right 时为什②不会被检索）
#### 中间值取法为 (left + right + 1) / 2 时
![826e05c46a7e499e82929cfbf2741496](https://user-images.githubusercontent.com/79822208/204230231-7d0e8cf2-ca4a-45b6-a272-08adba6042c8.png)
当left、mid、right 三数合一时：
- 若判断条件为 left <= right，循环继续，则点①也会被检索，所以为左闭右闭
- 若判断条件为 left <  right，循环结束，则点①点不会被检索，只有点②被检索，所以称为左开右闭（上图分析了 left < right 时为什么点①不会被检索）

### 经典的左闭右闭型

```cpp
int BinarySearch(int* arr,int tartget,int nums) {
  int left = 0;//左闭
  int right = nums - 1;//右关
  while(left <= right) { 
    auto mid = left + (right - left >> 1);
    if(arr[mid] < target)
      left = mid + 1;
    if(arr[mid] > target)
      right = mid - 1;
    else
      return mid;
  }
  return -1;
}
```
### 左闭右开型
```cpp
int lower_bound(int* arr,int target,int nums) {
  int left = 0;//左闭
  int right = nums;//右开
  //最终left mid right一定是三数合一然后跳出，且都在右侧，所以是第一个大于等于target的数
  while(left < right) {
    auto mid = left + (right - left >> 1);
    if(arr[mid] < target)
      left = mid + 1;
    else //arr[mid] >= target ,right向下收缩
      right = mid;//三数合一前，right一定在上界
  }
  
  if(left >= nums || arr[left] != target) return -1;
  return left;
}

int upper_bound(int* arr, int target, int nums) {
    int left = 0;
    int right = nums;
    while (left < right) {
        auto mid = left + ((right - left) >> 1);
        if (arr[mid] > target) {
            right = mid;//三数合一前，right一定在上界
        }
        else
            left = mid + 1;
    }

    if (left >= nums || arr[left] <= target) return -1;
    return left;
}
```

### 左开右闭型
```cpp
//小于taraget的最后一个数
int lower_max(int* arr, int target, int nums) {
    int left = 0;
    int right = nums;
    while (left + 1 < right) {
        auto mid = left + ((right - left + 1) >> 1);
        if (arr[mid] < target)
            left = mid;
        else 
            right = mid - 1;
    }

    if (left < 0 || arr[left] >= target) return -1;
    return left;
}
```

> https://blog.csdn.net/whc18858/article/details/122379930?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-122379930-blog-113779530.pc_relevant_multi_platform_whitelistv3&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-122379930-blog-113779530.pc_relevant_multi_platform_whitelistv3&utm_relevant_index=1
> https://oi-wiki.org/basic/binary/
