## 一、简单特性
### 1.namespace嵌套
```cpp
//c++17之前
namespace organism {
    namespace animal {
        namespace bird {

        }
    }
}
//c++17之后
namespace organism::animal::bird {

}
```

### 2.std::variant(升级版的C语言Union)
在C++17之前，通常使用Union来定义一个可以存储不同类型的变量，现在可以通过std::variant<T1,T2,...> 来定义一个可以存储不同类型的新变量。

std::variant优势在于：①存储了变量的类型信息，更安全；②可以存储复杂对象，更好用。

```cpp
#include <variant>
//可以存储自定义类型
struct MyData {
    int id;
    std::string name;
};

//std::variant<T1,T2>() 的默认值为T1()
std::variant<int, std::string, MyData> var;//默认值var = 0
var = 1;

//使用index()函数获取当前变量的类型信息
int type_id = var.index();// 当前为默认int类型，所以type_id = 0
//如果存储的是std::string类型，则type_id = 1

//std::get<index>(var>函数：以第一种类型——int，获得var值
int var_value = std::get<0>(var);//获取对应index的内容，如果没有存储的非获取的类型，有可能报错
//错误用法：std::get<index>()函数是模板函数，不能使用运行期确定的type_id来作为index
//int var_value = std::get<type_id>(var);


//std::holds_alternative<std::string>(var)：用来判断var的数据类型是否是T类型
bool is_store_string = std::holds_alternative<std::string>(var);//false
```

### 3.[[fallthrough]] 显式说明某个switch分支无需break
如果在写代码时遇到在swtich语句中需要执行完case 1，继续执行case 2的情况，可以使用[[fallthrough]]，此时编译器会忽略此处break语句检查，还能显式的告知Code Reviewer 此处是有意不写break语句。

用法如下：
```cpp
int Process(int n) {
    switch (n) {
    case 1:
        __fallthrough;//__fallthrough是[[fallthrough]]的宏定义，此时编译器不会警告没有break语句
    case 2: //此时编译器会警告没有break语句
    default:
        __fallthrough;//此时发生编译错误，因为最后一个分支不能使用
__fallthrough;

    }
}
```

### 4.[[nodiscard]] 显式说明不能忽略函数返回值
如果我们编写的某个函数不希望调用时忽略它的返回值，那么可以在函数声明处，使用[[nodiscard]]修饰这个函数。

用法如下：
```cpp
class Animal {};

//返货裸指针，如果使用者忽略则可能造成内存泄漏
_NODISCARD Animal* AnimalFactory() { //_NODISCARD为[[nodiscard]]的宏定义
    return new Animal();
}

AnimalFactory(); //此时编译器会在编译时候给出警告
```

## 二、std::optional 更优雅地编写可能无返回结果的函数
用法：
使用std::optional<T>来修饰函数返回值，表明这个函数可能不会返回值，T代表原有的返回类型。具体使用方法见示例函数TestOptionalInt：



