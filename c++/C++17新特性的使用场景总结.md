## 一、简单特性
### 1.namespace嵌套
```cpp
//c++17之前
namespace organism {
    namespace animal {
        namespace bird {

        }
    }
}
//c++17之后
namespace organism::animal::bird {

}
```

### 2.std::variant(升级版的C语言Union)
在C++17之前，通常使用Union来定义一个可以存储不同类型的变量，现在可以通过std::variant<T1,T2,...> 来定义一个可以存储不同类型的新变量。

std::variant优势在于：①存储了变量的类型信息，更安全；②可以存储复杂对象，更好用。

```cpp
#include <variant>
//可以存储自定义类型
struct MyData {
    int id;
    std::string name;
};

//std::variant<T1,T2>() 的默认值为T1()
std::variant<int, std::string, MyData> var;//默认值var = 0
var = 1;

//使用index()函数获取当前变量的类型信息
int type_id = var.index();// 当前为默认int类型，所以type_id = 0
//如果存储的是std::string类型，则type_id = 1

//std::get<index>(var>函数：以第一种类型——int，获得var值
int var_value = std::get<0>(var);//获取对应index的内容，如果没有存储的非获取的类型，有可能报错
//错误用法：std::get<index>()函数是模板函数，不能使用运行期确定的type_id来作为index
//int var_value = std::get<type_id>(var);


//std::holds_alternative<std::string>(var)：用来判断var的数据类型是否是T类型
bool is_store_string = std::holds_alternative<std::string>(var);//false
```

### 3.[[fallthrough]] 显式说明某个switch分支无需break
如果在写代码时遇到在swtich语句中需要执行完case 1，继续执行case 2的情况，可以使用[[fallthrough]]，此时编译器会忽略此处break语句检查，还能显式的告知Code Reviewer 此处是有意不写break语句。

用法如下：
```cpp
int Process(int n) {
    switch (n) {
    case 1:
        __fallthrough;//__fallthrough是[[fallthrough]]的宏定义，此时编译器不会警告没有break语句
    case 2: //此时编译器会警告没有break语句
    default:
        __fallthrough;//此时发生编译错误，因为最后一个分支不能使用
__fallthrough;

    }
}
```

### 4.[[nodiscard]] 显式说明不能忽略函数返回值
如果我们编写的某个函数不希望调用时忽略它的返回值，那么可以在函数声明处，使用[[nodiscard]]修饰这个函数。

用法如下：
```cpp
class Animal {};

//返货裸指针，如果使用者忽略则可能造成内存泄漏
_NODISCARD Animal* AnimalFactory() { //_NODISCARD为[[nodiscard]]的宏定义
    return new Animal();
}

AnimalFactory(); //此时编译器会在编译时候给出警告
```

## 二、std::optional 更优雅地编写可能无返回结果的函数
用法：
使用std::optional<T>来修饰函数返回值，表明这个函数可能不会返回值，T代表原有的返回类型。具体使用方法见示例函数TestOptionalInt：

```cpp
std::optional<int> TestOptionalInt(bool has_value) {
    if (has_value) return 2;
    else return std::nullopt; //函数没有返回值时返回nullopt
}

void TestOptionalA() {
    auto a = TestOptionalInt(true);
    if (a.has_value()) std::cout << *a;
    else std::cout << "a has not value";
}

void TestOptionalB() {
    auto a = TestOptionalInt(false);
    std::cout << *a; //在无返回值时，*a = 0；即int类型默认值
    //如果是T类型，则在无返回值时，*a = T()
}

TestOptionalA(); //输出2
TestOptionalB(); //输出0
```
### 用途：

过去当我们编写一个获取目标值的函数时，如果这个函数在某些情况下不能返回目标值，那么我们就必须通过两个参数去获得目标值：一个参数来表明是否存在目标值，另一个参数返回目标值；或者是在函数无返回值时抛出异常。下面以FindUserName函数来展示C++17之前的几种实现途径。
```cpp
#include<map>
std::map<int, std::string> user_map = { {1,"一号选手"} };

//方法一：返回pair类型
std::pair<bool, std::string> FindUserName(int id) {
    if (user_map.find(id) != user_map.end()) {
        return std::make_pair(true, user_map[id]);
    }
    else {
        return std::make_pair(false, "");
    }
}

//方法二：额外传入一个引用
bool FindUserName(int id, std::string& user_name) {
    if (user_map.find(id) != user_map.end()) {
        user_name = user_map[id];
        return true;
    }
    else {
        return false;
    }
}

//方法三：抛出异常
bool FindUserName(int id) {
    if (user_map.find(id) == user_map.end()) {
        throw "user id does not exist";
    }
    return user_map[id];
}

//引入C++17的std::optional<T>，我们可以更优雅更安全的编写FindUserName函数。

#include<map>
std::map<int, std::string> user_map = { {1,"一号选手"} };


std::optional<std::string> FindUserName(int id) {
    if (user_map.find(id) != user_map.end()) {
        return user_map[id];
    }
    else {
        return std::nullopt;
    }
}

//使用
std::string user_name;
auto find_result = FindUserName(1);
if (find_result.has_value()) {
    user_name = *find_result;
}
```
    
## 三、std::string_view 字符串视图
### 用法：
C++17引入的std::string_view来协助程序员更高效的使用只读字符串，初始化std::string_view时需要传入已有的字符串。作为函数参数时只使用值拷贝形式，即std::string_view；不要引用字符串视图，即：std::string_view&。

**std::string_view本质上是持有一个字符串的指针**，因此需要保证：①被持有的字符串生命周期比std::string_view变量长；②被持有的字符串在std::string_view变量生命周期结束之前，保持不变。
    
### 用途：
当遇到需要使用只读字符串，尤其是传入只读字符串作为函数参数时，优先使用std::string_view。在以下两个场景使用string_view比使用 const string&更好。

### 适用场景1：可能传入只读C风格字符串参数时
C风格字符串是指： const char* str = "C风格字符串"

char* str = "C风格字符串"

char[] str_array = "C风格字符串"

以一个字符串打印函数StringDisplay为例，下面的代码是常规的编写方法。

```cpp
//string_view不拷贝字符串，拷贝的是指针，所以要保证传入的字符串的生命周期
//要比string_view更长
void StringDisplay(std::string_view str) {
    std::cout << "std::string view 版本" << str << std::endl;
}
    
    

