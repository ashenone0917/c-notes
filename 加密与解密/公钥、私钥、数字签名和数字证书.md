### 公私钥加解密
![](https://github.com/ashenone0917/image/blob/main/670ddf02812a4789aa12901770f015de.png)  

Bob有两把钥匙，一把叫公钥(public key)，一把叫私钥(private key)。

![](https://github.com/ashenone0917/image/blob/main/161989e5a64f4c0c8210912022f2f4ae.png)  

Bob的公钥可以公开供其他人使用，他只保留自己的私钥。公钥和私钥用来加解密数据，如果使用任意一把来加密数据，那么只有使用另外一把才能解密数据(公用和私钥都可以加解密数据)  

![](https://github.com/ashenone0917/image/blob/main/3eefdc51188b4fc09b3ad8735f712d37.png)  

Susan想给Bob写信，她可以使用Bob的公钥将内容加密后发送给Bob，Bob收到以后，使用私钥解密以便阅读内容。Bob的其他同事即使截获了Susan发送给Bob的信件，由于没有Bob的私钥，也无法解密，从而确保数据安全。以上就是使用公钥和私钥加解密的过程演示。  

多说一句，如果Bob给Susan回信，如何保证数据安全呢？它可以使用Susan的公钥加密消息后发给Susan，Susan使用自己的私钥解密后阅读。所以保护好自己的私钥非常重要。

### 数字签名
现在Bob决定给Pat写一封信，信件的内容不用加密，但是要保证Pat收到信件后，能够确认信件确实是Bob发出的，而不是别人冒充Bob发给Pat的，应该怎么做？  

![](https://github.com/ashenone0917/image/blob/main/f1e289bf1eae47b099b5e75a9f2f6caf.png)  

Bob将信件通过hash软件计算一下，得到一串信息摘要(或hash值)。这一过程能够保证两点：
1. 过程不可逆。即不能通过消息摘要计算出信件的内容。
2. 消息摘要不会重复。即如果信件有任何改动，再次hash计算出的消息摘要一定不会和改动前的消息摘要一致。

![](https://github.com/ashenone0917/image/blob/main/f88b85cfdb4244e882bd83775aa061d1.png)  

然后，Bob使用自己的私钥，将消息
